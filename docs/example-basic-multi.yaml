esphome:
  name: bigbattery
  friendly_name: Big Battery
  comment: "AFERIY 3840Wh Portable Power Station"

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable Home Assistant API
api:
  encryption:
    key: "(PLACE YOU KEY HERE)"

ota:
  - platform: esphome
    password: "(PLACE YOU KEY HERE)"

# This assumed you put your WIFI SSID and passing in the secrets file
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Enable logging
logger:
  level: WARN

# Load external component from local path
external_components:
  - source: github://ylianst/esp-fbot
    refresh: 10s

# BLE Client configuration
ble_client:
  - mac_address: "AA:BB:CC:DD:EE:FF"  # Replace with your Fossibot 1 MAC address
    id: ble_client_1
  - mac_address: "11:22:33:44:55:66"  # Replace with your Fossibot 2 MAC address
    id: ble_client_2

# Configure the Fbot component. This component will inherit the ble_client above.
fbot:
  - id: fbot_device_1
    ble_client_id: ble_client_1
    polling_interval: 5s              # Status data (default: 2s)
    settings_polling_interval: 30s    # Holding registers (default: 60s)
  - id: fbot_device_2
    ble_client_id: ble_client_2
    polling_interval: 5s              # Status data (default: 2s)
    settings_polling_interval: 30s    # Holding registers (default: 60s)

# Binary sensors for connection and output states
binary_sensor:
  - platform: fbot
    fbot_id: fbot_device_1
    connected:
      name: "B1 Connected"
    # Optional sensors to indicate if the extra batteries 1 is connected
    battery_connected_s1:
      name: "B1 Connected S1"
    # Optional sensors to indicate if the extra batteries 2 is connected
    battery_connected_s2:
      name: "B1 Connected S2"
    usb_active:
      name: "B1 USB Active"
    dc_active:
      name: "B1 DC Active"
    ac_active:
      name: "B1 AC Inverter Active"
    light_active:
      name: "B1 Light Active"
  - platform: fbot
    fbot_id: fbot_device_2
    connected:
      name: "B2 Connected"
    # Optional sensors to indicate if the extra batteries 1 is connected
    battery_connected_s1:
      name: "B2 Connected S1"
    # Optional sensors to indicate if the extra batteries 2 is connected
    battery_connected_s2:
      name: "B2 Connected S2"
    usb_active:
      name: "B2 USB Active"
    dc_active:
      name: "B2 DC Active"
    ac_active:
      name: "B2 AC Inverter Active"
    light_active:
      name: "B2 Light Active"
  
# Sensors for battery and power readings
sensor:
  - platform: fbot
    fbot_id: fbot_device_1
    battery_level:
      name: "B1 Battery"
      id: b1_battery_percent
    # Optional sensors for the state of charge of extra battery 1
    battery_s1_level:
      name: "B1 Battery S1"
      id: b1_battery_percent_s1
    # Optional sensors for the state of charge of extra battery 2
    battery_s2_level:
      name: "B1 Battery S2"
      id: b1_battery_percent_s2
    ac_input_power:
      name: "B1 AC Input Power"
      id: b1_ac_input_watts
    dc_input_power:
      name: "B1 DC Input Power"
      id: b1_dc_input_watts
    input_power:
      name: "B1 Total Input Power"
      id: b1_input_watts
    output_power:
      name: "B1 Output Power"
      id: b1_output_watts
    system_power:
      name: "B1 System Power"
      id: b1_system_watts
    total_power:
      name: "B1 Total Output Power"
      id: b1_total_watts
    remaining_time:
      name: "B1 Remaining Minutes"
      id: b1_remaining_minutes
    # Optional sensors for charge/discharge thresholds
    threshold_charge:
      name: "B1 Charge Threshold"
      id: b1_threshold_charge
    threshold_discharge:
      name: "B1 Discharge Threshold"
      id: b1_threshold_discharge
    charge_level:
      name: "B1 Charge Level"
  # Convert remaining time from minutes to hours
  - platform: template
    name: "B1 Remaining Hours"
    lambda: |-
      if (id(b1_remaining_minutes).has_state()) {
        return id(b1_remaining_minutes).state / 60.0;
      }
      return 0.0;
    unit_of_measurement: "h"
    accuracy_decimals: 1
    device_class: duration
    state_class: measurement
    update_interval: 5s
  # Net power (positive = charging, negative = discharging)
  - platform: template
    name: "B1 Net Charging Power"
    lambda: |-
      if (id(b1_input_watts).has_state() && id(b1_output_watts).has_state()) {
        return id(b1_input_watts).state - id(b1_output_watts).state;
      }
      return 0.0;
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement
    update_interval: 5s
  - platform: fbot
    fbot_id: fbot_device_2
    battery_level:
      name: "B2 Battery"
      id: b2_battery_percent
    # Optional sensors for the state of charge of extra battery 1
    battery_s1_level:
      name: "B2 Battery S1"
      id: b2_battery_percent_s1
    # Optional sensors for the state of charge of extra battery 2
    battery_s2_level:
      name: "B2 Battery S2"
      id: b2_battery_percent_s2
    ac_input_power:
      name: "B2 AC Input Power"
      id: b2_ac_input_watts
    dc_input_power:
      name: "B2 DC Input Power"
      id: b2_dc_input_watts
    input_power:
      name: "B2 Total Input Power"
      id: b2_input_watts
    output_power:
      name: "B2 Output Power"
      id: b2_output_watts
    system_power:
      name: "B2 System Power"
      id: b2_system_watts
    total_power:
      name: "B2 Total Output Power"
      id: b2_total_watts
    remaining_time:
      name: "B2 Remaining Minutes"
      id: b2_remaining_minutes
    # Optional sensors for charge/discharge thresholds
    threshold_charge:
      name: "B2 Charge Threshold"
      id: b2_threshold_charge
    threshold_discharge:
      name: "B2 Discharge Threshold"
      id: b2_threshold_discharge
    charge_level:
      name: "B2 Charge Level"
  # Convert remaining time from minutes to hours
  - platform: template
    name: "B2 Remaining Hours"
    lambda: |-
      if (id(b2_remaining_minutes).has_state()) {
        return id(b2_remaining_minutes).state / 60.0;
      }
      return 0.0;
    unit_of_measurement: "h"
    accuracy_decimals: 1
    device_class: duration
    state_class: measurement
    update_interval: 5s
  # Net power (positive = charging, negative = discharging)
  - platform: template
    name: "B2 Net Charging Power"
    lambda: |-
      if (id(b2_input_watts).has_state() && id(b2_output_watts).has_state()) {
        return id(b2_input_watts).state - id(b2_output_watts).state;
      }
      return 0.0;
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement
    update_interval: 5s

# Switches to control outputs
switch:
  - platform: fbot
    fbot_id: fbot_device_1
    usb:
      name: "B1 USB Output"
      id: b1_usb_switch
    dc:
      name: "B1 DC Output"
      id: b1_dc_switch
    ac:
      name: "B1 AC Inverter"
      id: b1_ac_switch
    light:
      name: "B1 Light"
      id: b1_light_switch
    ac_silent:
      name: "B1 AC Silent Charging"
      id: b1_ac_silent_switch
  - platform: fbot
    fbot_id: fbot_device_2
    usb:
      name: "B2 USB Output"
      id: b2_usb_switch
    dc:
      name: "B2 DC Output"
      id: b2_dc_switch
    ac:
      name: "B2 AC Inverter"
      id: b2_ac_switch
    light:
      name: "B2 Light"
      id: b2_light_switch
    ac_silent:
      name: "B2 AC Silent Charging"
      id: b2_ac_silent_switch

# Number controls for charge/discharge thresholds
number:
  - platform: fbot
    fbot_id: fbot_device_1
    # Charge threshold: stop charging when battery reaches this level (10-100%)
    threshold_charge:
      name: "B1 Charge Max"
      min_value: 10
      max_value: 100
      step: 1
    # Discharge threshold: stop discharging when battery reaches this level (0-50%)
    threshold_discharge:
      name: "B1 Discharge Min"
      min_value: 0
      max_value: 50
      step: 1
  - platform: fbot
    fbot_id: fbot_device_2
    # Charge threshold: stop charging when battery reaches this level (10-100%)
    threshold_charge:
      name: "B2 Charge Max"
      min_value: 10
      max_value: 100
      step: 1
    # Discharge threshold: stop discharging when battery reaches this level (0-50%)
    threshold_discharge:
      name: "B2 Discharge Min"
      min_value: 0
      max_value: 50
      step: 1
